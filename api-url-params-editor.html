<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/elements/dom-if.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../iron-validatable-behavior/iron-validatable-behavior.html">
<link rel="import" href="../paper-checkbox/paper-checkbox.html">
<link rel="import" href="api-url-params-form.html">

<dom-module id="api-url-params-editor">
  <template strip-whitespace>
    <style>
    :host {
      display: block;
      @apply --raml-request-parameters-editor;
      @apply --api-url-params-editor;
    }

    .empty-message {
      @apply --raml-request-parameters-editor-no-params;
      @apply --api-url-params-editor-no-params;
    }

    .empty-message p {
      @apply --raml-request-parameters-editor-no-params-message;
      @apply --api-url-params-editor-no-params-message;
    }

    [hidden] {
      display: none !important;
    }
    </style>
    <section hidden$="[[hasParameters]]" class="empty-message">
      <p>This endpoint doesn't require to declare query or URI parameters.</p>
    </section>
    <template is="dom-if" if="[[hasUriParameters]]">
      <section>
        <api-url-params-form id="uriParametersForm" form-type="uri" model="{{uriModel}}" form-title="URI parameters" optional-opened></api-url-params-form>
      </section>
    </template>
    <template is="dom-if" if="[[hasQueryParameters]]">
      <section>
        <api-url-params-form id="queryParametersForm" form-title="Query parameters" allow-hide-optional form-type="query" model="{{queryModel}}"></api-url-params-form>
      </section>
    </template>
  </template>
  <script>
    /**
     * `api-url-params-editor`
     * An element to render query / uri parameters form from AMF schema
     *
     * This element is to replace `raml-request-parameters-editor` which can
     * only work with RAML parser custom data model.
     *
     * Use `api-url-params-editor` to generate pre-populated form of query and
     * uri paramters for an API endpoint. It accepts [AMF](https://github.com/mulesoft/amf)
     * json/ld model for an API to render the view.
     *
     * This element works together with `api-url-editor`. Both elements uses
     * the same view data model generated by
     * [api-view-model-transformer](https://github.com/advanced-rest-client/api-view-model-transformer)
     * element. Because of that neither this or `api-url-editor` does not include
     * the transformer since they both work with the same data model.
     * If you use this elements separatelly you have to use the transformer
     * to generate the view data model.
     *
     * This element does not produce URL for the endpoint. It informs other
     * elements about user input by:
     * - updating the data model with user input and propagate those changes
     * through the listeners
     * - sending `uri-parameter-changes` and `query-parameter-changed` events.
     *
     * The element that generates full URL for the endpoint is `api-url-editor`
     * that listens for the change events and updates URL value.
     *
     * This element listens for the change events and updates values (without
     * notifications) if values are different.
     *
     * Use `eventsTarget` property to scope events to a single node.
     *
     * For special cases you may want to use this element and handle events
     * manually, without using `api-url-input`. If not, then it's easier to
     * use `api-request-editor` and an element tah bound all request editors
     * togeter and produce commong HTTP request object.
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     * @memberof ApiElements
     * @appliesMixin Polymer.IronValidatableBehavior
     */
    class ApiUrlParamsEditor extends
      Polymer.mixinBehaviors([Polymer.IronValidatableBehavior], Polymer.Element) {
      static get is() { return 'api-url-params-editor'; }
      static get properties() {
        return {
          /**
           * Computed by `api-view-model-transformer` qury parameters model.
           *
           * Note, this element won't accept AMF data.
           */
          queryModel: Array,
          /**
           * Computed value if the `queryParameters` are set.
           * Use `raml-request-parameteres-model` to compute this value.
           */
          hasQueryParameters: {
            type: Boolean,
            computed: '_computeHasData(queryModel)'
          },
          /**
           * Computed by `api-view-model-transformer` URI parameters model.
           *
           * Note, this element won't accept AMF data.
           */
          uriModel: Array,
          /**
           * Computed value if the `uriParameters` are set.
           * Use `raml-request-parameteres-model` to compute this value.
           */
          hasUriParameters: {
            type: Boolean,
            computed: '_computeHasData(uriModel)'
          },
          /**
           * Computed value if `uriParameters` or `queryParameters` are set.
           * Use `raml-request-parameteres-model` to compute this value.
           */
          hasParameters: {
            type: Boolean,
            computed: '_computeHasParameters(hasQueryParameters, hasUriParameters)'
          },
          // regexp to match query parameters model change
          _queryModelMatcher: {
            type: Object,
            value: function() {
              return /queryModel.(\d+).(name|value|schema\.enabled)/;
            }
          },
          // regexp to match uri parameters model change
          _uriModelMatcher: {
            type: Object,
            value: function() {
              return /uriModel.(\d+).(name|value|schema\.enabled)/;
            }
          },
          /**
           * Map of uri parameters produced by this element.
           */
          uriValue: {
            type: Object,
            notify: true
          },
          /**
           * Map of query parameters produced by this element.
           */
          queryValue: {
            type: Object,
            notify: true
          }
        };
      }

      static get observers() {
        return [
          '_queryModelChanged(queryModel.*)',
          '_uriModelChanged(uriModel.*)'
        ];
      }
      /**
       * Computes boolean value if the argument exists and has items.
       *
       * @param {Array} model Current url model.
       * @return {Boolean}
       */
      _computeHasData(model) {
        return !!(model && model.length);
      }
      /**
       * Computes value for `hasParameters` property.
       *
       * @param {Boolean} qp State of `hasQueryParameters`
       * @param {Boolean} up State of `hasUriParameters`
       * @return {Boolean} True if any of the arguments is true
       */
      _computeHasParameters(qp, up) {
        return qp || up;
      }

      // Overidden from Polymer.IronValidatableBehavior. Will set the `invalid`
      // attribute automatically, which should be used for styling.
      _getValidity() {
        let validUri = true;
        let validUrl = true;
        if (this.hasUriParameters) {
          validUri = this.shadowRoot.querySelector('#uriParametersForm').validate();
        }
        if (this.hasQueryParameters) {
          validUrl = this.shadowRoot.querySelector('#queryParametersForm').validate();
        }
        return validUri && validUrl;
      }
      /**
       * Handler for query model change in path.
       * Calls `_modelChanged()` function with `type` set to `query`
       *
       * @param {Object} record
       */
      _queryModelChanged(record) {
        this._modelChanged('query', record);
      }
      /**
       * Handler for query model change in path.
       * Calls `_modelChanged()` function with `type` set to `uri`
       *
       * @param {Object} record
       */
      _uriModelChanged(record) {
        this._modelChanged('uri', record);
      }
      /**
       * Handles model path change.
       * Informs listeners about the change and produces parameters output.
       *
       * @param {String} type Data model type. `query` or `uri`
       * @param {Object} record Model change record.
       */
      _modelChanged(type, record) {
        if (!record || !record.path) {
          return;
        }
        if (record.path === 'uriModel' || record.path === 'queryModel') {
          this._renotifyModelChange(type);
          this._updateModelValue(type);
        } else if (['model.length', 'model.splices'].indexOf(record.path) !== -1) {
          return;
        } else {
          const re = type === 'uri' ? this._uriModelMatcher :
            this._queryModelMatcher;
          const matches = record.path.match(re);
          if (!matches) {
            return;
          }
          const item = this.get([type + 'Model', Number(matches[1])]);
          this._notifyChange(type, item);
          this._updateValue(type, item);
        }
      }
      /**
       * Sends change notification when entire model change.
       *
       * @param {String} type Data model type. `query` or `uri`
       */
      _renotifyModelChange(type) {
        const model = type === 'uri' ? this.uriModel : this.queryModel;
        if (!model || !model.length) {
          return;
        }
        model.forEach((item) => this._notifyChange(type, item));
      }
      /**
       * Notifies about paramter change.
       *
       * @param {String} type Data model type. `query` or `uri`
       * @param {Object} model Model item.
       */
      _notifyChange(type, model) {
        let enabled = model.schema && model.schema.enabled;
        if (typeof enabled === 'boolean') {
          enabled = true;
        }
        const ev = new CustomEvent(type + '-parameter-changed', {
          detail: {
            name: model.name,
            value: model.value,
            enabled: enabled
          },
          cancelable: true,
          bubbles: true,
          composed: true
        });
        this.dispatchEvent(ev);
      }
      /**
       * Update generated value for a model.
       * @param {String} type Data model type. `query` or `uri`
       * @param {Object} item Model item
       */
      _updateValue(type, item) {
        const path = type + 'Value';
        const enabled = item.schema && item.schema.enabled;
        const result = this[path] || {};
        this[path] = undefined;
        if (enabled === false) {
          delete result[item.name];
        } else {
          result[item.name] = item.value;
          // this.set([path, item.name].join('.'), item.value);
        }
        this.set(path, result);
      }
      /**
       * Updates value for entire model.
       * @param {String} type Data model type. `query` or `uri`
       */
      _updateModelValue(type) {
        const path = type + 'Value';
        const model = type === 'uri' ? this.uriModel : this.queryModel;
        if (!model || !model.length) {
          this.set(path, undefined);
          return;
        }
        const result = {};
        model.forEach((item) => {
          let enabled = item.schema && item.schema.enabled;
          if (enabled === false) {
            return;
          }
          result[item.name] = item.value;
        });
        this.set(path, result);
      }

      /**
       * Fired when an URI parameter value change in this editor.
       *
       * @event uri-parameter-changed
       * @param {String} name The name of the parameter
       * @param {String} value The value of the parameter
       * @param {Boolean} enabled True if the parameter is enabled in the form.
       */
      /**
       * Fired when a query parameter value change in this editor.
       *
       * @event query-parameter-changed
       * @param {String} name The name of the parameter
       * @param {String} value The value of the parameter
       * @param {Boolean} enabled True if the parameter is enabled in the form.
       */
    }

    window.customElements.define(ApiUrlParamsEditor.is, ApiUrlParamsEditor);
  </script>
</dom-module>
